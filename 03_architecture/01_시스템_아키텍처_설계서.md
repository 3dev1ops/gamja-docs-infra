# 시스템 아키텍처 설계서 (System Architecture Specification)

## 1. 시스템 구성도 (System Architecture Diagram)

전체 서비스의 인프라 및 네트워크 구성을 정의합니다. 클라이언트 요청이 처리되는 전체적인 흐름을 시각화합니다.

```mermaid
graph TD
    User[Client (Web/Mobile)] -->|HTTPS| LB[Load Balancer (AWS ALB)]
    LB -->|API Request| FE[Frontend Server (React SPA)]
    LB -->|WebSocket| WAS[Backend WAS (Spring Boot)]
    
    subgraph VPC [AWS VPC]
        FE
        WAS
        
        WAS -->|Read/Write| DB[(Primary DB - PostgreSQL)]
        WAS -->|Cache/PubSub| Redis[(Redis Cluster)]
        WAS -->|Store Images| S3[AWS S3]
    end
    
    subgraph CI_CD [CI/CD Pipeline]
        Github[GitHub] -->|Push| Actions[GitHub Actions]
        Actions -->|Build & Deploy| Docker[Docker Registry]
        Docker -->|Pull Image| FE
        Docker -->|Pull Image| WAS
    end
```

### 1.1 주요 구성 요소
- **Client**: 웹 브라우저 및 모바일 환경 (React 기반 SPA)
- **Load Balancer**: AWS ALB를 사용하여 트래픽 분산 및 SSL 종료
- **Frontend Server**: React SPA (Vercel/S3 등 정적 호스팅 또는 컨테이너)
- **Backend Server**: Kotlin + Spring Boot 기반의 API 서버 및 WebSocket 서버 (경매 입찰 실시간 처리)
- **Database**: PostgreSQL (관계형 데이터 저장), Redis (실시간 경매 데이터 캐싱, 세션 관리, Pub/Sub)
- **File Storage**: AWS S3 (상품 이미지 등 대용량 정적 파일 저장)

---

## 2. 기술 스택 (Tech Stack)

### 2.1 Dashboard
| 구분 | 기술 스택 | 선정 이유 |
| :--- | :--- | :--- |
| **Frontend** | React | 컴포넌트 기반 개발, 풍부한 라이브러리 생태계 |
| | TypeScript | 정적 타입 지정을 통한 안정성 확보 |
| | TailwindCSS | 빠른 UI 개발 및 일관된 디자인 시스템 적용 |
| | Zustand/Recoil | 가벼운 전역 상태 관리 (필요 시 선택) |
| | React Query | 서버 상태 비동기 관리 및 캐싱 |
| **Backend** | Kotlin, Spring Boot | 강력한 엔터프라이즈급 프레임워크, 안정성 및 확장성 우수 |
| | Spring Data JPA / QueryDSL | 표준화된 데이터 접근 계층 및 타입 안전한 쿼리 작성 |
| **Database** | PostgreSQL | 신뢰성 높은 관계형 데이터베이스, 복잡한 비즈니스 로직 처리에 적합 |
| | Redis | 인메모리 DB로 실시간 입찰 정보 처리(Pub/Sub) 및 캐싱 |
| **Infra/DevOps** | (논의 중) | 팀원들과 협의하여 무료/유료 티어 적합성 검토 후 결정 |
| | Docker | 일관된 개발 및 배포 환경 보장 |
| | GitHub Actions | 자동화된 CI/CD 파이프라인 구축 |

### 2.2 인프라 및 배포 환경 논의 (Infrastructure Candidates)

학생/사이드 프로젝트 팀을 위한 무료 호스팅 옵션을 비교하여 결정한다.

| 옵션 | 구성 (Frontend + Backend + DB) | 장점 | 단점 |
| :--- | :--- | :--- | :--- |
| **1. Oracle Cloud** | Vercel + OCI VM (Spring Boot) + OCI DB/Docker | **평생 무료** (4 OCPU, 24GB RAM). Spring Boot 구동에 가장 넉넉한 자원. | 가입 심사가 까다롭고 서울 리전 생성이 어려울 수 있음. |
| **2. AWS Free Tier** | Vercel + EC2 (t2/t3.micro) + RDS | 가장 표준적이고 레퍼런스가 많음. | **1년 후 유료** 전환. 1GB RAM으로 Spring Boot 운영 시 스왑 메모리 설정 필수. |
| **3. PaaS 조합** | Vercel + Render/Fly.io + Supabase/Neon | 설정이 매우 간편하고 관리가 필요 없음. | 무료 티어 메모리가 적어(약 512MB) Spring Boot 구동이 불안정할 수 있음. |

> **권장 사항**: **Oracle Cloud** 가입을 최우선으로 시도하되, 실패 시 **AWS 프리티어**를 사용하여 1년간 운영하는 방안을 추천함. Frontend는 **Vercel**을 사용하여 무료 호스팅과 CI/CD 편의성을 챙김.

---

## 3. 데이터베이스 설계 (ERD Concept)

주요 엔티티 간의 관계를 정의합니다. 상세 모델링 전 개념적 설계를 보여줍니다.

```mermaid
```

### 3.1 주요 테이블 설명
- **USERS**: 회원 정보 (카카오/구글 소셜 로그인 연동)
- **ITEMS**: 판매 물품 정보 (제목, 설명, 카테고리 등)
- **AUCTIONS**: 경매 관련 메타데이터 (시자가, 현재가, 종료 시간, 상태 등). 실시간성이 중요하므로 Redis와 동기화 고려.
- **BIDS**: 입찰 내역 로그. 모든 입찰 시도를 기록하여 추후 분쟁 해결 및 이력 관리에 사용.
- **ORDERS**: 낙찰 후 거래 정보 (거래 상태, 결제 정보 등)

---

## 4. 인터페이스 및 통신 설계

### 4.1 API 통신 방식
- **RESTful API**: 일반적인 CRUD 작업(사용자 조회, 상품 등록, 목록 조회 등)에 사용
    - 명확한 리소스 기반 URI 설계 (예: `GET /api/v1/items/:id`)
    - JSON 포맷 사용

### 4.2 실시간 통신
- **WebSocket (Socket.io)**: 실시간성이 중요한 경매 입찰 및 타이머 동기화에 필수
    - **Namespace/Room**: 각 경매 상품(`auction_id`)별로 Room을 생성하여 데이터 전송 범위를 격리
    - **이벤트 정의**:
        - `bid`: 클라이언트가 입찰 요청 전송
        - `bid_update`: 서버가 입찰 성공 시 해당 방의 모든 유저에게 새로운 가격과 입찰자 정보 브로드캐스트
        - `auction_end`: 경매 종료 시 낙찰자 정보 알림

---

## 5. 주요 프로세스 시퀀스 (Key Process Sequence)

### 5.1 실시간 입찰 프로세스 (Real-time Bidding Flow)

### 5.2 경매 종료 프로세스 (Auction End Flow)
